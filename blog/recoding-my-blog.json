{"title":"Recoding my blog","slug":"recoding-my-blog","tags":["#svelte","#sapper","#serverless","#python","#javascript"],"date":"2020-07-12","html":"\n\t\t<p class=\"post_p\">\nDuring quarantine I had more free time than usual so I decided it was time\nto modernize my <a href=\"https://albertopou.dev/\" class=\"post_link\" target=\"_blank\">blog</a>.\nI coded the first version 5 years ago choosing technologies\nsimply because I knew them. That resulted in a <a href=\"https://www.djangoproject.com/\" class=\"post_link\" target=\"_blank\">Django</a>\n app with a <a href=\"https://www.postgresql.org/\" class=\"post_link\" target=\"_blank\">Postgres</a> database \n and an outdated design using <a href=\"https://getbootstrap.com/\" class=\"post_link\" target=\"_blank\">Bootstrap</a>.  \nAfter the years I used to use my blog to test new technologies so I had versions \nof my blog using <a href=\"https://jquery.com/\" class=\"post_link\" target=\"_blank\">JQuery</a>,\n<a href=\"https://vuejs.org/\" class=\"post_link\" target=\"_blank\">Vue</a>, Django, Django 2.0 \nusing a DDD approach, ... and it was deployed on <a href=\"https://www.digitalocean.com/\" class=\"post_link\" target=\"_blank\">Digital Ocean</a>,\n<a href=\"https://aws.amazon.com/\" class=\"post_link\" target=\"_blank\">AWS</a>,\n<a href=\"https://www.heroku.com/\" class=\"post_link\" target=\"_blank\">Heroku</a>, \nHeroku using <a href=\"https://www.terraform.io/\" class=\"post_link\" target=\"_blank\">Terraform</a>, ... \nAnyone who saw the code could say that a blog should never be so over-engineer, and I agree. For this \nreason I decided to check which technologies were being used nowadays to make simple blogs.  \n\t\t</p>\n\t\t<p class=\"post_p\">\nMy goal was to make a simple, fast and modern blog which allows me to write posts easily, \ndeploy them on <a href=\"https://pages.github.com/\" class=\"post_link\" target=\"_blank\">Github Pages</a> \nand, of course, spend as little time as possible on maintenance. After check several technologies \na co-worker told me about <a href=\"https://svelte.dev/\" class=\"post_link\" target=\"_blank\">Svelte</a>\nand I loved it. Svelte and its server-rendering backend <a href=\"https://sapper.svelte.dev/\" class=\"post_link\" target=\"_blank\">Sapper</a>\nwere what I was looking for and there were a lot of examples of blogs made with these technologies.  \nAfter that I just required a new design. I was tired about Bootstrap designs so I was looking \nfor something new, and then I found <a href=\"https://tailwindcss.com/\" class=\"post_link\" target=\"_blank\">Tailwind</a>. \nTailwind had all that I needed. A framework which, after memorize some easy classes, allows you not to write CSS. Maybe for \nyou this is not a plus feature but for me, a backend coder, it was perfect. \n\t\t</p>\n\t\t<h4 class=\"post_section_title text-2xl text-bold\">The good parts of this architecture</h4>\n\t\t<p class=\"post_p\">\nAfter this introduction I want to list the advantages that I found making my \nblog with Svelte, Sapper and Tailwind. Remember that this benefits I found exist in \nthe case of study of a simple blog. \n\t\t</p>\n\t\t<ul class=\"post_list\">\n<li>\n\t<strong>Easy installation</strong>. Sapper has a great initial template and several pre-configured commands\n\twhich allows you to focus on the important parts of your project. \n</li>\n<li>\n\t<strong>Great development environment</strong>. Live reload! When you modify some file, the navigator\n\treloads the page automatically. Maybe I'm overestimating this feature but I work everyday in an outdated\n\tfrontend and this feature drove me crazy!\n</li>\n<li>\n\t<strong>Static page</strong>. Sapper allows you to export your project as a static site. \n\tThen it can be hosted and served as static files, which allows it to be deployed on hosting\n\tenvironments such as Github Pages. To serve the page as static files also improves\n\tthe speed notoriously, obtaining better results in web positioning. You can use apps as \n\t<a href=\"https://developers.google.com/web/tools/lighthouse\" class=\"post_link\" target=\"_blank\">Lighthouse</a> to check this.\n</li>\n<li>\n\t<strong>Elegant syntax</strong>. I worked with different frontend technologies such as JQuery, \n\t<a href=\"https://knockoutjs.com/\" class=\"post_link\" target=\"_blank\">Knockout</a>, \n\t <a href=\"https://angular.io/\" class=\"post_link\" target=\"_blank\">Angular</a> or Vue \n\tand Svelte syntax looks perfect for me. It's easy to understand, simple and elegant. In the following section you'll \n\tbe able to check it in a easy example I'll show you.  \n</li>\n<li>\n\t<strong>Component structure</strong>. One thing normally I don't like in a frontend based project is \n\tthe way how developers structure the code. Last years I was working in projects where component HTML, Javascript and\n\tspecific CSS were in different folders and then developers loose to much time searching the \n\tJavascript or de CSS associated to a particular template. Svelte joins all in one file (.svelte) and\n\tin my opinion is a great solution to improve the components reusability.\n</li>\n<li>\n\t<strong>Speed</strong>. Svelte is based on reactivity. To understand easily which reasons \n\tallows Svelte to get such good results in terms of speed compared to other frameworks you can watch this \n\t<a href=\"https://www.youtube.com/watch?v=gJ2P6hGwcgo\" class=\"post_link\" target=\"_blank\">great conference</a>\n\tof its creator Rich Harris.\n</li>\n<li>\n\t<strong>No CSS</strong>. With Tailwind you don't need to write CSS code. With its pre-defined classes\n\tyou can make pretty much anything.\n</li>\n<li>\n\t<strong>Easy personalization</strong>. At Tailwind config file you can configure stuff as main \n\tcolors, default spacing, text font, ... and using @apply CSS sentence you can create your own classes easily.\n</li>\n<li>\n\t<strong>0 costs</strong>. With this architecture I was able to have my blog with 0 costs (I just have to pay the domain). \n</li>\n\t\t</ul>\n\t\t<p class=\"post_p\">\nNow I'm going to show\nyou how I made the comments engine using <a href=\"https://www.serverless.com/\" class=\"post_link\" target=\"_blank\">Serverless</a> and Svelte\nas an example of use of these frameworks.\n\t\t</p>\n\t\t<h4 class=\"post_section_title text-2xl text-bold\">Persistent storage for comments</h4>\n\t\t<p class=\"post_p\">\nA comments engine requires a persistent storage so I needed to add something else to the blog in order to allow users to write comments.\nServerless is a framework that makes easier to mount a serverless infrastructure with AWS. In this case I decided\nto use <a href=\"https://aws.amazon.com/dynamodb/\" class=\"post_link\" target=\"_blank\">Dynamo DB</a>\nto store post user comments and <a href=\"https://aws.amazon.com/lambda/\" class=\"post_link\" target=\"_blank\">Lambda</a> to get and publish comments.\nThis functions are not all time waiting for requests in a server (for this reason is so cheap).\nAWS Lambda deploys them very fast just when they are invoked by different events such as queue events, S3 changes, HTTP requests, .... \nIn this case the event was going to \nbe an HTTP request to the <a href=\"https://aws.amazon.com/api-gateway/\" class=\"post_link\" target=\"_blank\">AWS API Gateway</a>.\n\t\t</p>\n\t\t<p class=\"post_p\">\nAll this could seem very complex but with a framework as Serverless is done with a simple config file. \n<a href=\"https://github.com/bertini36/bertini36.github.io/blob/develop/lambdas/serverless.yml\" class=\"post_link\" target=\"_blank\">Here</a>\nyou have the config file I wrote to have 2 lambda functions (at 2 different endpoints), one for \nget post comments and another to publish new ones. At this config file you can configure several things, from\nlanguage used and access management till requests rate limits and database resources. In this case the configuration is very simple, \nthe 2 lambda functions are 2 views of a simple <a href=\"https://flask.palletsprojects.com/en/1.1.x/\" class=\"post_link\" target=\"_blank\">Flask</a> application. \nThis views just get the comments or stores a new one in the database (in this case Dynamo DB, you can check the databse repository \n<a href=\"https://github.com/bertini36/bertini36.github.io/blob/develop/lambdas/repository.py\" class=\"post_link\" target=\"_blank\">here</a>).\n\t\t</p>\n\t\t<div class=\"post_code\">\n<pre><code>from flask import Flask, jsonify, request\nfrom flask_cors import CORS, cross_origin\n\nfrom exceptions import RepositoryException\nfrom repository import comments_repository\n\napp = Flask(__name__)\ncors = CORS(app)\napp.config['CORS_HEADERS'] = 'Content-Type'\n\n\n@app.route('/comments/<string:post_slug>', methods=['GET'])\n@cross_origin()\ndef get_comments(post_slug):\n    try:\n        comments = comments_repository.get_comments(post_slug)\n        if comments:\n            return jsonify(comments), 200\n        return jsonify({'error': 'Comments not found'}), 404\n    except RepositoryException as e:\n        return jsonify({'error': str(e)}), 500\n\n\n@app.route('/comments/<string:post_slug>', methods=['POST'])\n@cross_origin()\ndef add_comment(post_slug):\n    try:\n        comments_repository.add_comment(post_slug, request.get_json())\n        return jsonify({}), 200\n    except RepositoryException as e:\n        return jsonify({'error': str(e)}), 500\n\n</code></pre>\n\t\t</div>\n\t\t<p class=\"post_p\">\nIf you need you can check the rest of the \n<a href=\"https://github.com/bertini36/bertini36.github.io/tree/develop/lambdas\" class=\"post_link\" target=\"_blank\">code</a>.\n\t\t</p>\n\t\t<p class=\"post_p\">\nNow we need a Svelte component that gets the comments of a post and publish new ones using the endpoints created with Serverless. In the following\ncode you can revise the component part required to get and show the comments of a post (.svelte file).\n\t\t</p>\n\t\t<div class=\"post_code\">\n<pre><code>&lt;script&gt;\n   export let slug;\n   const comments_url = `dummy.com/prod/comments/${slug}`;\n   let comments = getComments();\n\t\n   async function getComments() {\n      const response = await fetch(comments_url);\n      if (!response.ok) throw new Error(text);\n      return await response.json();\n    }\n&lt;/script&gt;\n\n{#await comments}\n   &lt;figure class=\"flex justify-center\">&lt;img class=\"w-48\" src=\"loader.gif\" alt=\"Loader\"&gt;&lt;/figure&gt;\n{:then comments}\n   {#each comments as comment}\n      &lt;div class=\"shadow bg-white rounded-md mb-1\" role=\"alert\"&gt;\n         &lt;div class=\"p-4 flex\"&gt;\n            &lt;div class=\"pl-2\"&gt;\n               &lt;p class=\"font-bold text-gray-700\"&gt;{comment.text}&lt;/p&gt;\n               &lt;p class=\"text-gray-600\"&gt;\n                  {comment.name} &lt;span class=\"text-gray-500 text-sm\"&gt;{comment.date}&lt;/span&gt;\n                &lt;/p&gt;\n            &lt;/div&gt;\n         &lt;/div&gt;\n      &lt;/div&gt;\n   {/each}\n{:catch error}\n   &lt;p>No comments yet&lt;/p&gt;\n{/await}\n</code></pre>\n\t\t</div>\n\t\t<p class=\"post_p\">\nI'm using {#await} Svelte declarative to wait the fetch promise of the comments request. Svelte\nis going to manage the comments as soon as the promise ends and then comments will be rendered\nusing {#each} declarative. All classes used to give styles are Tailwind classes. If you want to see\nthe rest of the code to publish new comments \n<a href=\"https://github.com/bertini36/bertini36.github.io/blob/develop/src/components/Comments.svelte\" class=\"post_link\" target=\"_blank\">here</a> \nyou have the complete component and the result online is just below!\n\t\t</p>\n\t\t<p class=\"post_p\">\nFeel free to ask anything in the comments section!\n\t\t</p>\n\t\t"}